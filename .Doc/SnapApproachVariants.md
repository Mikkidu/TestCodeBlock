# Варианты реализации магнитного снапа блоков

## Вариант A: Explicit Connection Points (Явные точки подключения) ⭐ РЕКОМЕНДУЕТСЯ

### Концепция
Каждый блок имеет явные маленькие UI элементы (кружки) обозначающие входы и выходы.

### Визуализация
```
Палитра:                           ProgramArea:
┌─────────────────────┐           ┌─────────────────────┐
│   Move Forward      │           │   Move Forward      │
│                     │           │                     │
●   Input point     ●  Output     ●                   ●
└─────────────────────┘           └─────────────────────┘
                                           ↓ snap
                                   ┌─────────────────────┐
                                   │   Turn Right        │
                                   │                     │
                                   ●                   ●
                                   └─────────────────────┘
```

### При перетаскивании
```
Ближайший Output в snapDistance:

┌─────────────────────┐
│   Move Forward      │
│                     │
│                   ●  ← Target Output
└─────────────────────┘
       ↑
       │ snap distance (e.g., 50px)
       │
     ● ← Input точка перетаскиваемого блока

При close proximity блок подсвечивается зеленым/синим
```

### Архитектура
```csharp
BlockConnector
├── pointType: Input | Output
├── visualElement: RectTransform (маленький кружок)
└── parameterType: ParameterType (будущее)

BlockUI
├── inputPoints: List<BlockConnector>   // обычно 1
├── outputPoints: List<BlockConnector>  // 1 сейчас, много в будущем
└── FindNearestOutput(): BlockConnector
```

### Преимущества
✅ Явная архитектура - легко понять и расширять
✅ Поддержка множественных выходов (для If/Else блоков)
✅ Можно визуализировать линии-связи в будущем
✅ Заложена база для параметров между блоками
✅ Интуитивно для пользователя - ясно видно где подключается
✅ Профессиональное решение (как в визуальных языках программирования)

### Недостатки
❌ Нужно создавать UI элементы для каждого блока
❌ Немного сложнее логика поиска ближайшей точки
❌ Зависит от позиционирования элементов

### Сложность реализации
⏱️ Средняя (2-3 часа на основную функцию)

---

## Вариант B: Implicit Edge-Based Snapping (Снап по краям)

### Концепция
Снап основан на близости краев блоков. Нижний край одного блока примагничивается к верхнему краю другого.

### Визуализация
```
Нет явных точек:

┌─────────────────────┐
│   Move Forward      │  ← Нижний край = Output
└─────────────────────┘
     ↓ snapDistance = 20px

     🔺 Курсор тянет блок

     ↓ snapDistance = 20px
┌─────────────────────┐
│   Turn Right        │  ← Верхний край = Input
└─────────────────────┘
```

### При перетаскивании
```
Поиск ближайшего блока с нижним краем в зоне snapDistance
↓
Выравнивание по Y позиции
↓
При drop блок встанет ровно под выходом
```

### Архитектура
```csharp
// Простая - просто расчеты расстояний между RectTransform элементами

BlockUI.OnDrag()
{
    BlockUI nearest = FindNearestBlockBelow(snapDistance: 20f);
    if (nearest != null)
    {
        // Примагнитить к нижнему краю
        float targetY = nearest.GetComponent<RectTransform>().rect.yMin;
        transform.position = new Vector3(transform.position.x, targetY, transform.position.z);
    }
}
```

### Преимущества
✅ Простая реализация - минимум кода
✅ Нет дополнительных UI элементов
✅ Быстро разработать (1-2 часа)
✅ Понятная логика

### Недостатки
❌ Невозможно поддержать множественные выходы (If/Else)
❌ Нельзя визуализировать линии связи
❌ Неясно где точно произойдет подключение
❌ Проблемы если выход находится не в центре блока
❌ Не масштабируется на будущее

### Сложность реализации
⏱️ Простая (1-2 часа)

---

## Вариант C: Hybrid (Гибридный подход)

### Концепция
Явные точки подключения как в A, но их позиции определяются автоматически на основе CommandType и других параметров.

### Визуализация
```
BlockFactory.CreateBlock(CommandType.MoveForward)
    ↓
Автоматически создаются точки:
- Input: вверху в центре
- Output: внизу в центре
    ↓
┌─────────────────────┐
│   Move Forward      │
●  (auto-placed)   ●  (auto-placed)
└─────────────────────┘
```

### Архитектура
```csharp
BlockFactory.CreateBlock(CommandType cmd)
{
    BlockUI block = Instantiate(blockPrefab);

    // Автоматическое создание точек на основе типа команды
    block.SetupConnectorPoints(cmd);

    return block;
}

BlockUI.SetupConnectorPoints(CommandType cmd)
{
    // Создать Input (всегда вверху)
    CreateInputPoint(topCenter);

    // Создать Output(ы) в зависимости от типа
    switch(cmd.Type)
    {
        case Normal:        // Move, Turn, Wait
            CreateOutputPoint(bottomCenter);
            break;
        case Conditional:   // If, While (в будущем)
            CreateOutputPoint(bottomLeft);   // True
            CreateOutputPoint(bottomRight);  // False
            break;
    }
}
```

### Преимущества
✅ Гибридный подход - явная архитектура + автоматизм
✅ Поддержка множественных выходов
✅ Упрощенное создание блоков
✅ Меньше ручных позиционирований

### Недостатки
❌ Требует изменений в BlockFactory
❌ Сложнее отладить если что-то не совпадает
❌ Зависит от логики автоопределения позиций

### Сложность реализации
⏱️ Средне-сложная (2-3 часа)

---

## Сравнительная таблица

| Критерий | Вариант A | Вариант B | Вариант C |
|----------|-----------|----------|-----------|
| **Сложность реализации** | 2-3ч | 1-2ч | 2-3ч |
| **Множественные выходы** | ✅ Да | ❌ Нет | ✅ Да |
| **Визуализация связей** | ✅ Да | ❌ Нет | ✅ Да |
| **Параметры между блоками** | ✅ Готово | ❌ Нет | ✅ Готово |
| **Масштабируемость** | ⭐⭐⭐ | ⭐ | ⭐⭐ |
| **Интуитивность UI** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| **Код-простота** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **Для будущих блоков** | ✅ Идеально | ❌ Плохо | ✅ Хорошо |

---

## Рекомендация: **Вариант A** ⭐

### Почему именно A?

1. **Будущее расширение** - вы сказали "в будущем будут блоки с несколькими выходами"
   - Вариант A готов к этому
   - Вариант B придется переписывать

2. **Параметры между блоками** - архитектура заложена
   - Вариант A имеет инфраструктуру (parameterType в BlockConnector)
   - Варианты B и C не готовы

3. **Профессиональный вид** - визуально похоже на Unreal Blueprints, UE Blueprint, Scratch
   - Пользователи поймут логику сразу

4. **Линии-связи** - в будущем захотите рисовать линии между точками
   - Вариант A это поддерживает
   - Вариант B нет

5. **Тестируемость** - каждый этап разработки проверяется
   - Как я написал в плане - 7 проверяемых этапов
   - Можете останавливаться и проверять работу на каждом этапе

### План: Вариант A (7 проверяемых этапов)

1. **Инфраструктура** - создать BlockConnector класс
2. **Визуализация** - маленькие кружки на блоках
3. **Поиск** - логика FindNearestOutput
4. **Feedback** - подсвечивание при близости
5. **Применение** - снап при OnEndDrag
6. **Связи команд** - обновление ICommand.Next
7. **Параметры** - заготовка для будущего

Каждый этап занимает 15-30 минут, можно проверить результат.

---

## Окончательный выбор

```
Вариант A: Explicit Connection Points ⭐ РЕКОМЕНДУЕТСЯ
```

Согласны с этим выбором или хотите обсудить варианты B/C?
