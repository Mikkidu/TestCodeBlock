# #10b Снап в середину цепи

## Goal
Реализовать вставку блока в **середину цепи** (между двумя существующими блоками) с правильным переконектированием соединений.

**Сценарий:**
```
Было:  [Block A] → [Block B] → [Block C]

Пользователь перетащит Block X, подносит его выход к входу Block B
Становится: [Block A] → [Block X] → [Block B] → [Block C]
             (X вставлена между A и B)
```

## Context
- После завершения #10a у нас есть FindNearestInput и ApplySnapToInput
- ApplySnapToInput уже делает почти то же самое для вставки в середину!
- Различие: при вставке в начало нет OUTPUT'а подключенного к входу (он пустой)
- При вставке в середину есть OUTPUT подключенный к INPUT (нужно его перенаправить)
- Логика в ApplySnapToInput уже это учитывает → просто нужно проверить что работает

## Key Steps

1. **Проверить корректность ApplySnapToInput для вставки в середину**
   - ApplySnapToInput должна обработать случай когда уже есть OUTPUT подключенный к targetInput
   - Логика:
     ```
     если targetInput.connectedFrom существует (какой-то OUTPUT подключен):
         перенаправить этот OUTPUT на OUTPUT перетаскиваемого блока
     подключить OUTPUT перетаскиваемого к targetInput
     ```

2. **Добавить вспомогательный метод для поиска подключенного OUTPUT'а**
   - В BlockConnector или SnapManager добавить метод FindConnectedOutput(input)
   - Поискать во всех блоках какой OUTPUT.connectedTo == input
   - Вернуть этот OUTPUT или null

3. **Улучшить визуальный feedback при вставке в середину**
   - Когда OUTPUT перетаскиваемого близко к INPUT середины цепи
   - Показать preview: как будет перенаправлена старая связь
   - Возможно подсветить оба соединения (старое и новое)

4. **Обновить OnDrop() логику**
   - Она уже должна работать благодаря #10a
   - Просто протестировать что вставка в середину работает
   - Проверить что FindNearestInput корректно работает для всех блоков

5. **Тестирование - комплексное**
   - Добавить Block A
   - Добавить Block B (snap в конец → A→B)
   - Добавить Block C (snap в конец → A→B→C)
   - Перетащить Block X, вставить между A и B
     - Результат: A→X→B→C
   - Перетащить Block Y, вставить между X и B
     - Результат: A→X→Y→B→C
   - Запустить программу
   - Проверить логи [EXECUTE] что цепь правильная
   - Запустить несколько раз - убедиться что цепь не нарушается

## Acceptance Criteria
- [ ] ApplySnapToInput корректно переконектирует соединения при вставке в середину
- [ ] FindConnectedOutput находит OUTPUT подключенный к INPUT'у
- [ ] Вставка в середину работает для разных позиций в цепи
- [ ] Визуальный feedback показывает правильное переконектирование
- [ ] Цепь выполняется в корректном порядке после вставок
- [ ] GetFirstBlock() всегда возвращает правильный первый блок
- [ ] Debug логи показывают все переконектированные соединения

## Blockers & Risks
- Нужно быть осторожным с порядком переконектирования (может быть race condition?)
- Возможны проблемы если вставить блок который уже подключен где-то (нужна валидация)
- Вставка может нарушить цепь если логика ошибочна

## Notes
- Большинство логики уже в #10a (FindNearestInput, ApplySnapToInput)
- Эта задача в основном тестирование и debug
- После этой задачи система snap будет полной и готовой к циклам (#11)
- Можно добавить "undo" функцию для вставки ошибочной позиции

## Визуальный пример

```
ИСХОДНО:
[A out]──→[B in] [B out]──→[C in] [C out]──→END

ВСТАВЛЯЕМ X МЕЖДУ A И B:
[A out]──→[X in]
          [X out]──→[B in] [B out]──→[C in] [C out]──→END

ЛОГИКА:
1. Найдешм что OUTPUT А подключен к INPUT B
2. Разорваем: [A out] → NULL
3. Перенаправляем: [A out] → [X in]
4. Подключаем: [X out] → [B in]
5. Результат: A → X → B → C
```
