# #10a Снап в начало цепи

## Goal
Реализовать снап выхода перетаскиваемого блока ко входу **первого блока в цепи**. Позволяет вставлять новые блоки в начало программы.

**Сценарий:**
```
Было:  [Block A] → [Block B]
       (A = первый блок)

Пользователь перетащит Block C, подносит его выход к входу Block A
Становится: [Block C] → [Block A] → [Block B]
            (C теперь первый блок)
```

## Context
- SnapManager уже имеет FindNearestOutput для поиска ближайшего OUTPUT к INPUT перетаскиваемого блока
- Нужно добавить FindNearestInput для поиска ближайшего INPUT к OUTPUT перетаскиваемого блока
- При снапе в начало: переподключить A→B в C→A→B
- GetFirstBlock() должен обновиться автоматически (так как C не имеет входящего соединения)

## Key Steps

1. **Добавить FindNearestInput в SnapManager**
   - Получить OUTPUT точку перетаскиваемого блока (последний OUTPUT или может быть несколько?)
   - Для каждого блока в программе проверить его INPUT точки
   - Найти ближайший INPUT к OUTPUT перетаскиваемого блока
   - Вернуть SnapInfo с targetBlock и targetInput

2. **Создать ApplySnapToInput в SnapManager**
   - Параметры: перетаскиваемый блок, его OUTPUT, целевой INPUT
   - Выполнить логику:
     ```
     oldConnection = найти какой OUTPUT был подключен к targetInput
     если oldConnection существует:
         oldConnection.connectedTo = null  // разорвать старую связь
         draggingBlockOutput.connectedTo = oldConnection.connectedTo  // перенаправить на выход перетаскиваемого

     draggingBlockOutput.connectedTo = targetInput  // новое соединение
     ```
   - Вызвать OnSnap событие

3. **Логика в OnDrop() - сначала проверить вставку в начало**
   - Сначала пытаться FindNearestInput (снап выхода к входу)
   - Если найдено и расстояние < snapDistance → ApplySnapToInput
   - Если нет → пытаться FindNearestOutput (как раньше) для снапа в конец
   - Если и то нет → блок остается где drop

4. **Визуальный feedback - различие двух типов snap**
   - При близости OUTPUT к INPUT: подсветить INPUT желтым (отличается от красного OUTPUT)
   - При близости INPUT к OUTPUT: подсветить OUTPUT желтым
   - Четко видно какой тип соединения будет

5. **Тестирование**
   - Добавить Block A в ProgramArea
   - Добавить Block B (должна snap'нуться к A, создав A→B)
   - Перетащить Block C, подносить выход к входу A
   - Должна snap'нуться: C→A→B
   - Запустить программу
   - Проверить логи [CONNECTION] и [EXECUTE] что порядок C→A→B
   - Проверить что GetFirstBlock() возвращает C

## Acceptance Criteria
- [ ] FindNearestInput находит ближайший INPUT на нужном расстоянии
- [ ] ApplySnapToInput правильно переподключает старую связь
- [ ] OnDrop проверяет сначала FindNearestInput перед FindNearestOutput
- [ ] Визуальный feedback различает INPUT и OUTPUT подсветку
- [ ] GetFirstBlock() возвращает новый первый блок (без входящего соединения)
- [ ] Цепь выполняется в порядке C→A→B
- [ ] Debug логи показывают [CONNECTION] с новой последовательностью

## Blockers & Risks
- Нужна осторожность при разорвании старого соединения - проверить что оно существует
- Возможны проблемы если несколько OUTPUT'ов на блоке (для начала работаем с одним)
- Нужно убедиться что GetFirstBlock() правильно обновляется

## Notes
- Для начала предполагаем один OUTPUT на блоке
- GetFirstBlock() должен работать автоматически благодаря логике "блок без входящего соединения"
- После этой задачи сразу можно переходить на #10b (вставка в середину)
